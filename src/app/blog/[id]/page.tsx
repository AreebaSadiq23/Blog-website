import Layout from "../../components/Layout";
import { notFound } from "next/navigation";
import Image from "next/image";
import Comments from "../../components/Comments";

type BlogPost = {
  id: string;
  title: string;
  content: string;
  imageUrl: string;
  date: string;
}

const blogPosts: Record<string, BlogPost> = {
  "3": {
    id: "3",
    title: "The Power of Tailwind CSS",
    content:
      "Tailwind CSS has taken the web development world by storm, providing a utility-first approach to styling that is fast, flexible, and efficient. Unlike traditional CSS frameworks like Bootstrap, which come with predefined components and themes, Tailwind CSS offers a more customized approach, allowing developers to create unique designs without leaving the HTML file.\n\n### What is Tailwind CSS?\n\nTailwind CSS is a utility-first CSS framework that gives developers a set of low-level utility classes to build custom designs without writing custom CSS. With Tailwind, you compose your UI directly in your HTML by adding utility classes that apply specific styles such as padding, margin, font sizes, colors, etc.\n\nUnlike other CSS frameworks that dictate the structure of your website's design, Tailwind CSS provides a highly customizable system where you can tweak the design to suit your needs. Tailwind’s utility-first approach encourages you to build the layout with smaller building blocks, offering more control and less bloat in your final code.\n\n### Why Use Tailwind CSS?\n\n1. **Faster Development Process**\n\nTailwind allows developers to build layouts and designs much faster than traditional CSS. You don’t have to constantly switch between your HTML and CSS files. Everything is handled directly in the HTML file through utility classes, making it quicker to prototype and iterate on designs.\n\n2. **Highly Customizable**\n\nTailwind gives you complete control over the design. With its extensive configuration options, you can adjust the default settings for spacing, colors, fonts, breakpoints, etc., to match your project’s branding and aesthetic needs. You can even add custom utilities and create your own design system.\n\n3. **No Opinionated Styles**\n\nUnlike frameworks like Bootstrap that impose a specific design language, Tailwind CSS doesn’t come with predefined components or design decisions. This means you have complete creative freedom. You can create a design that perfectly fits your vision, without being limited by predefined themes or UI components.\n\n4. **Consistency and Maintainability**\n\nUsing utility classes throughout your project ensures consistency in design. Tailwind’s class names are intuitive and follow a clear naming convention, making it easier to maintain and update your design. You don’t need to worry about naming collisions or overriding styles, as you would with traditional CSS.\n\n5. **Smaller File Sizes**\n\nTailwind's `purge` feature allows you to remove unused CSS in production, resulting in smaller file sizes. When you build your project for production, Tailwind removes all the utility classes that you didn’t use, ensuring that your website loads faster and performs better.\n\n6. **Mobile-First Approach**\n\nTailwind CSS is built with mobile-first design in mind, meaning that it’s optimized for responsive web development right out of the box. With its responsive utilities, you can easily control how elements behave on different screen sizes, ensuring that your website looks great on mobile, tablet, and desktop devices.\n\n### Tailwind CSS in Action\n\nTailwind is extremely powerful when it comes to creating custom layouts and designs. Some of the key features of Tailwind include:\n\n- **Flexbox and Grid Utilities**: Tailwind makes it simple to use Flexbox and CSS Grid layouts with utility classes like `flex`, `grid`, `justify-center`, `items-center`, and `gap-4`.\n- **Responsive Design**: Tailwind comes with built-in responsive classes that allow you to design for different screen sizes without writing complex media queries. Simply prefix your classes with `sm:`, `md:`, `lg:`, etc.\n- **State Variants**: Tailwind allows you to add states to your classes, such as `hover:`, `focus:`, `active:`, etc., enabling you to style elements dynamically based on user interactions.\n\nExample of Tailwind’s utility-first approach:\n```html\n<button class=\"px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-700 transition ease-in-out duration-200\">Click Me</button>\n```\nThis example is built entirely with utility classes, which not only makes it easy to style but also highly customizable.\n\n### Tailwind CSS vs. Traditional CSS\n\nThe main difference between Tailwind CSS and traditional CSS is the approach to styling. With traditional CSS, you define styles in a separate CSS file and apply them to HTML elements using class names or IDs. Tailwind, on the other hand, is a utility-first approach, where you apply styles directly to elements in the HTML by adding utility classes. This can seem unconventional at first, but once you get used to it, you’ll find it’s an efficient way to build UIs.\n\n### Conclusion\n\nTailwind CSS is a powerful, flexible, and highly customizable framework that simplifies web development. Its utility-first approach allows for faster development, better maintainability, and a smaller file size. It’s perfect for developers who want more control over their designs without relying on predefined components or themes. With Tailwind, you can create beautiful, unique, and responsive websites quickly and efficiently.\n\nTailwind’s growing popularity in the web development community speaks to its effectiveness, and it’s likely to continue shaping the future of front-end development.\n\nStart using Tailwind CSS today, and take your web development skills to the next level!",
    imageUrl: "/images/tail.png",
    date: "Dec 30, 2024",
  },
  "4": {
    id: "4",
    title: "Next.js 15: What's New and Why It Matters",
    content:
      "Next.js, the popular React framework, has been continuously evolving to provide developers with better performance, more flexibility, and new features that simplify the development process. With the release of Next.js 15, the framework introduces several new updates that make it even more powerful for building modern, performant web applications. In this post, we’ll take a closer look at the key features of Next.js 15 and why they matter for developers.\n\n### What’s New in Next.js 15?\n\n#### 1. **Enhanced Image Optimization**\n\nImage optimization has always been a key feature of Next.js, but with version 15, it’s taken to the next level. The framework now supports even better image loading strategies, providing automatic lazy loading for images by default. This improves performance by deferring the loading of images until they are needed, reducing the initial page load time.\n\nMoreover, Next.js 15 introduces improved image resizing capabilities, ensuring that images are served at the correct dimensions and formats for the user’s device. With these updates, developers can deliver fast-loading websites without compromising on image quality.\n\n#### 2. **Server Components and Streaming**\n\nNext.js 15 brings the power of server-side rendering and React Server Components together. This new feature allows developers to offload some of the rendering logic to the server, resulting in faster page loads and better overall performance.\n\nServer Components allow you to render parts of your application on the server, which means that you can send only the necessary HTML to the client, reducing JavaScript bundle sizes. This is particularly beneficial for large applications, as it ensures that the client only receives the code required for that specific view.\n\nIn addition, streaming allows React Server Components to be streamed from the server as they are rendered. This means that users will see content as soon as it is ready, without having to wait for the entire page to load.\n\n#### 3. **Improved Development Experience with React 18 Support**\n\nNext.js 15 is fully compatible with React 18, offering support for the new Concurrent Rendering and Suspense features. These updates allow you to build more responsive and interactive UIs by rendering multiple pieces of content in parallel, instead of blocking the rendering process while waiting for one part to finish.\n\nWith React 18, React Suspense has been extended to support data fetching, making it easier to manage the loading states of various components in your application. The integration of these features in Next.js ensures that you can take full advantage of React’s modern capabilities and enhance your user experience.\n\n#### 4. **Better Routing and Layouts**\n\nNext.js 15 introduces a more intuitive and flexible routing system. The new file-based routing system makes it easier to organize your project and handle dynamic routes. With the addition of layouts, developers can create reusable UI patterns across pages without having to repeat themselves.\n\nLayouts are now a core part of the Next.js ecosystem, allowing developers to define page layouts that can be shared across different views. This can help you maintain consistency in your design and reduce code duplication.\n\n#### 5. **Edge Functions for Improved Performance**\n\nNext.js 15 introduces edge functions, enabling developers to run code closer to the user’s location, which results in faster response times and better performance. By deploying your application on edge locations, you can reduce latency and improve load times, particularly for users located in different geographical regions.\n\nEdge functions bring Next.js closer to the world of serverless computing, enabling developers to scale their applications more efficiently by executing code at the edge of the network.\n\n### Why Next.js 15 Matters\n\nThe new features introduced in Next.js 15 are a game-changer for web development. Let’s take a look at why they matter:\n\n1. **Performance Optimization**: With improvements like enhanced image optimization, server-side rendering, and edge functions, Next.js 15 helps developers build faster, more performant websites. As performance is a critical factor in user experience and SEO, these updates are essential for creating modern web applications.\n\n2. **Better Developer Experience**: Next.js 15 simplifies the development process by offering an improved routing system, support for React 18’s Concurrent Rendering, and an easier way to manage layouts. These features reduce complexity and help developers build more maintainable and scalable applications.\n\n3. **Scalability and Flexibility**: The introduction of server components, streaming, and edge functions enhances the scalability of applications. Developers can now create applications that perform well, even as traffic scales and geographical locations become more diverse.\n\n4. **Future-Proofing Your Applications**: With its support for the latest web technologies, such as React 18 and serverless architecture, Next.js 15 ensures that developers can build applications that are ready for the future, without needing to worry about obsolescence.\n\n### Conclusion\n\nNext.js 15 represents a significant leap forward for the React framework, providing developers with better performance, enhanced scalability, and a more intuitive development experience. With key features like improved image optimization, server-side rendering, and edge functions, Next.js 15 is poised to empower developers to build faster, more efficient, and highly scalable web applications.\n\nAs web performance and user experience continue to be a priority, Next.js 15’s new features will play a crucial role in shaping the future of modern web development. Whether you're building a small project or a large-scale enterprise application, Next.js 15 is an essential tool to consider for your next project.",
    imageUrl: "/images/nextjs.png",
    date: "Dec 30, 2024",
  },
  "5": {
    id: "5",
    title: "The Power of TypeScript",
    content:
      "In the ever-evolving world of web development, JavaScript has long been the dominant language for building interactive and dynamic web applications. However, as applications grow in complexity, developers often find JavaScript's loose typing and lack of built-in tooling challenging. This is where TypeScript, a statically typed superset of JavaScript, comes into play. In this post, we'll explore the power of TypeScript and why it is becoming the go-to choice for modern web development.\n\n### What is TypeScript?\n\nTypeScript is a language that builds on top of JavaScript, adding optional static typing, interfaces, and other features that make it easier to build scalable, maintainable, and bug-free applications. Developed and maintained by Microsoft, TypeScript is designed to enhance JavaScript with the safety of type checking, while still compiling down to JavaScript to ensure compatibility with all browsers and JavaScript environments.\n\n### Why TypeScript?\n\n1. **Static Typing**\n\nOne of the most powerful features of TypeScript is its static typing. While JavaScript is a dynamically typed language (meaning variables can hold any type of data at runtime), TypeScript allows developers to define the types of variables, function parameters, and return values at compile-time. This helps catch type-related errors early in the development process, leading to more reliable code.\n\nExample:\n```typescript\nlet age: number = 25;\nlet name: string = \"John\";\n```\nThe compiler will catch errors if a variable is assigned an incorrect type, preventing potential runtime errors.\n\n2. **Better Tooling and Editor Support**\n\nTypeScript’s static types provide better editor support. Many modern IDEs and text editors (such as Visual Studio Code) offer features like auto-completion, real-time type checking, and inline documentation, all thanks to TypeScript’s type system. This leads to a more productive and efficient development experience.\n\n3. **Improved Code Maintainability**\n\nAs projects grow larger, managing and maintaining code becomes more difficult. TypeScript helps by enforcing type safety and providing features like interfaces and type aliases, making it easier to understand how different parts of the application interact. This is especially beneficial in large teams or when working on long-term projects.\n\nExample:\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n}\nconst person: Person = { name: \"Alice\", age: 30 };\n```\nThis approach improves readability and makes it easier for new developers to join the project.\n\n4. **Early Bug Detection**\n\nTypeScript provides compile-time error checking, which means that many bugs can be detected before the code is even run. This early detection saves time during the debugging process and leads to fewer runtime errors in production. By catching potential issues before they arise, TypeScript helps ensure a more stable and bug-free application.\n\n5. **Compatibility with JavaScript**\n\nTypeScript is fully compatible with existing JavaScript code. You can gradually adopt TypeScript by converting parts of your codebase to TypeScript while still using JavaScript for other parts. This makes the transition to TypeScript seamless and allows developers to benefit from its features incrementally.\n\nExample:\n```typescript\nlet x = 10; // JavaScript code\nlet y: number = 20; // TypeScript code\n```\n\n6. **Object-Oriented Programming (OOP) Features**\n\nTypeScript supports OOP concepts like classes, interfaces, and inheritance, making it easier to structure code in an object-oriented manner. This is particularly useful for developers who are familiar with languages like Java or C# and prefer an OOP approach for their applications.\n\nExample:\n```typescript\nclass Person {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  greet() {\n    console.log(`Hello, ${this.name}!`);\n  }\n}\n```\n\n7. **Scalability**\n\nAs applications grow in size and complexity, maintaining and scaling the codebase becomes increasingly difficult. TypeScript’s features, such as interfaces, types, and modules, provide a structured approach to building scalable applications. TypeScript ensures that all parts of the application fit together correctly, making it easier to expand and maintain over time.\n\n8. **Ecosystem and Community**\n\nTypeScript has a rapidly growing community, and it’s widely supported by many popular libraries, frameworks, and tools. Whether you're working with Angular, React, Node.js, or any other modern JavaScript framework, you can count on TypeScript’s seamless integration. Additionally, TypeScript provides type definitions for many JavaScript libraries, so you can enjoy the benefits of static typing even when using third-party packages.\n\n### How to Get Started with TypeScript\n\nGetting started with TypeScript is easy. You can either install TypeScript globally via npm or add it to your existing JavaScript project.\n\n1. Install TypeScript:\n```bash\nnpm install -g typescript\n```\n\n2. Create a `tsconfig.json` file to configure your project settings:\n```bash\ntsc --init\n```\n\n3. Start writing TypeScript code by renaming your `.js` files to `.ts` and adding type annotations as needed.\n\n4. Compile the TypeScript files into JavaScript:\n```bash\ntsc\n```\n\n### Conclusion\n\nTypeScript has emerged as a powerful tool for modern web development. Its static typing, improved tooling, and ability to catch bugs early in the development process make it an excellent choice for developers who want to write clean, maintainable, and scalable code. By offering features like object-oriented programming, compatibility with JavaScript, and better developer tooling, TypeScript has quickly become a game-changer in the world of JavaScript development.\n\nIf you're working on a JavaScript project, whether it's small or large, transitioning to TypeScript can significantly improve your development experience and lead to more reliable applications. By leveraging TypeScript's power, you’ll be able to build applications with confidence, knowing that your code is safer, more maintainable, and easier to scale.",
    imageUrl: "/images/typescript.jpg",
    date: "Dec 26, 2024",
  },
  "6": {
    id: "6",
    title: "GraphQL vs REST: Choosing the Right API",
    content:
      "APIs are essential for connecting different parts of an application. REST and GraphQL are two popular approaches for building APIs. REST is simple and uses multiple endpoints for different resources, while GraphQL provides a flexible, single-endpoint solution where you can request exactly the data you need. REST works well for straightforward projects, but GraphQL is ideal for complex apps requiring high performance and customized data fetching. Choosing the right API depends on your project's needs.",
    imageUrl: "/images/api.jpg",
    date: "Dec 20, 2024",
  },
};

type PageProps = {
  params: { id: string };
};

export default function BlogPost({ params }: PageProps) {
  const post = blogPosts[params.id as keyof typeof blogPosts];

  if (!post) {
    notFound();
  }

  return (
    <Layout>
      <article className="max-w-3xl mx-auto">
        <Image
          src={post.imageUrl}
          alt={post.title}
          width={800}
          height={400}
          className="w-full h-64 object-cover shadow-md mb-8"
        />
        <h1 className="text-4xl font-bold mb-4 text-gray-800 dark:text-gray-100">
          {post.title}
        </h1>
        <p className="text-gray-500 dark:text-gray-400 mb-8">{post.date}</p>
        <div className="prose lg:prose-xl dark:prose-invert leading-relaxed">
          <p>{post.content}</p>
        </div>
        <Comments postId={params.id} />
      </article>
    </Layout>
  );
}

export async function generateStaticParams() {
  return Object.keys(blogPosts).map((id) => ({
    id: id,
  }));
}
